{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-yun-dev/source/Yun.png","path":"Yun.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/yun.ico","path":"yun.ico","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/yun.svg","path":"yun.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/css/hexo-theme-yun.styl","path":"css/hexo-theme-yun.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/gallery-decrypt.js","path":"js/gallery-decrypt.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/hexo-theme-yun.js","path":"js/hexo-theme-yun.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/pjax.js","path":"js/pjax.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/say.js","path":"js/say.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/sidebar.js","path":"js/sidebar.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/search/algolia-search.js","path":"js/search/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/ui/banner.js","path":"js/ui/banner.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/ui/fireworks.js","path":"js/ui/fireworks.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-yun-dev/source/js/ui/mode.js","path":"js/ui/mode.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/friends.json","hash":"91aa5605aabd08d9797ef6288cc2060dccb02824","modified":1599632306711},{"_id":"source/_posts/typescript-1.md","hash":"d834f3aab9ecbdf5d5a27214182badc409e731de","modified":1600248461149},{"_id":"source/.DS_Store","hash":"f6a9e8d9177dbd8239ee4d40af58fc17cf9b5746","modified":1599616320158},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1599559481603},{"_id":"source/_posts/typescript-2.md","hash":"05019441130846d477dfffcba29cc72ee22f5a30","modified":1600248623367},{"_id":"source/about/index.md","hash":"7381843ffd2f41cc9a70e3e9ea80894cde6f4bf9","modified":1599632077990},{"_id":"source/archives/index.md","hash":"ac38bf32002c93a09bc605423c06bd0318ddcd74","modified":1599632186249},{"_id":"source/categories/index.md","hash":"0c6fa2ca9f2a33ae43e4b92ff5d7c7399affcb92","modified":1599632042422},{"_id":"source/contact/index.md","hash":"5eec74904190695e4b162ef8290e4f6a1e4d219a","modified":1599632832255},{"_id":"source/_posts/typescript-3.md","hash":"eace35a706db22f5f6268042ef0a02943b981de5","modified":1600249617291},{"_id":"source/tags/index.md","hash":"c6ddedc1460d4b1ca23de5179c5384836309c65b","modified":1599632059708},{"_id":"source/friends/index.md","hash":"a966d2739a36405c30fb259948ad97949919fc12","modified":1599632156314},{"_id":"themes/hexo-theme-yun-dev/scripts/injector/index.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/.gitignore","hash":"b9e34fe2544e88baff4129db394ce0cd4a29893e","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/LICENSE","hash":"a24ce67b002ff38718c549129d23d177bf951dbf","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/README.md","hash":"45170b355c8297d3764b2fab3d02a0efa15bae10","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/_config.yml","hash":"46f59fb39b3400883773c5cdeb27940daf3f0faa","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/_vendors.yml","hash":"756311cc429dbd66a81408a29098ca6d57cf96b8","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/package.json","hash":"2dd575e50c9e330216cdc538fdb0284c2c50edfe","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/.github/FUNDING.yml","hash":"41b293d76a307f29e81d931edb1c6d05fed526fd","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/README.md","hash":"1509cc59c0dd1ef3314ca3078425a87f20495a63","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/about.md","hash":"18d60a62db0653f37c54b96c4ab6ad947c4b368e","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/demo.md","hash":"bd2ac8d8eecfea4688ce778bd099666d5abfc565","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/languages/default.yml","hash":"e56bebd19d2abd1698e9aa87d337941957977468","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/languages/en.yml","hash":"2a7e1e7e0256669c9baf5a89f75f451abbe9f5dc","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/languages/ja.yml","hash":"ab9ae6ae6ed8850d33a2301ec2a19262bae0fbf4","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/languages/zh-CN.yml","hash":"7335025328bba8cb6aaca1c6aa5aa56c08c3602c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/404.pug","hash":"39719b1b4300ed7d12b062eec4186bda5dede7c2","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/archive.pug","hash":"067ac814d892dc6c0efe9c03c45abd712648e37e","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/category.pug","hash":"6d0a910ac2716c1acae5e7ab0c2a56e4d5438281","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/gallery.pug","hash":"a79bed685d6d8adfa6be776adf078f880d85d9b7","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/girls.pug","hash":"9fce3f9e013e0118161f1d19ae2f06065e5c133f","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/index.pug","hash":"7322ea6d9cfb29b1bb13a31bb5f98abcf5d9f409","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/links.pug","hash":"354d2f6822e748b38dd67876cce32d3d8e9a85da","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/page.pug","hash":"756be355b95237d539c1aa84bc7bfcfee033c274","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/post.pug","hash":"0ce118c7033dc07357a771a38d1cc93b8f73edad","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/slide.pug","hash":"9582b6053d979dc78154410dc5bf47941b67c8e7","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/tag.pug","hash":"936517e7783217eac36e55f027ff383f1cd5c3da","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/Yun.png","hash":"b8ae426fa5dd7579d23d189c222641d812c51c0a","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/yun.ico","hash":"5d63418cd650d1881d4b6507f35b9f9df766020e","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/yun.svg","hash":"aa027a0a9e7ba96c906b9fd2d9cd3f8018ff2e2d","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/.github/ISSUE_TEMPLATE/bug_report.md","hash":"fc6cae3cfcc963b0f9cfb91f3a703362c2ecd945","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/.github/ISSUE_TEMPLATE/feature_request.md","hash":"62827149319963e12671b8522850423eceea2eb0","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/.github/ISSUE_TEMPLATE/usage_problem.md","hash":"6127e821a2f673c1b1604ccf1e8d9c062389eb0c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/.github/workflows/docs.yml","hash":"529956828792a03d8b882edd89fedb5613beaa84","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/config.js","hash":"a90ba88a5e5bed11c44a6b2bee667a939a257056","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/README.md","hash":"4b7a325b5f0d97d6bc4af65cf86a576dedf45dde","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/about.md","hash":"19f69d579ba7770c732306c6c66642f4d170220d","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/guide/README.md","hash":"8bf2d78487a143c7776f0dd582959ab5e78318bf","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/guide/additional-package-support.md","hash":"7838481f12385819ddd5647915d4cac65919e324","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/guide/config.md","hash":"678233a113796f1e70af4ea22beb7cd68eb580ad","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/guide/faq.md","hash":"6875e60626526960b7eb1b2f02f952b8088b3f0b","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/guide/icon.md","hash":"05fe25b14d29dcd9dc6bfad27f2e40c68c1a9929","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/guide/migrate.md","hash":"a865536d769d82500bfc58ab2ace3641880c5ba9","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/guide/page.md","hash":"9bf82c802e7d09760082263563bedb6e98a5e3c0","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/guide/third-party-support.md","hash":"493755b6364cf8bec407d6bb9396b3e60360d6b7","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_mixin/icon.pug","hash":"18ee2c33b4e6ef71c31d7955f9a20789fe6aa9e4","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_mixin/index.pug","hash":"3969072910506b21cb09ea2a69f718110c1bb23c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_mixin/page-header.pug","hash":"b72bf2a802d48ca05ff9ffc6dfe92c9701f1cc87","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_mixin/post-collapse.pug","hash":"741195a5a29ecb5863b1fd0c3b203d960aae05c1","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/background.pug","hash":"53b9607f2c68d852d2c082a6588f66af0e681b68","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/banner.pug","hash":"33ed4a88492e1f66bd7db40ff23b2f3487a88cb7","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/footer.pug","hash":"377bcbb76b2d2e89d4b830cc614485aae5d0ef87","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/head.pug","hash":"b9f69108c550d4f36accece509dcc661b03cfdb6","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/layout.pug","hash":"75e8a2c375482797b850638ae2d9eeb2402d378b","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/pagination.pug","hash":"b55b6a99b105447b4a6c982fa258680a2a9a34a9","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/recent-posts.pug","hash":"e1d1cfae1d445afc09f0b3c35e96739b531b6c72","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/sidebar.pug","hash":"4375f4a52c6751f9ade4fb1f738c5b48d33c9c62","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/aplayer.pug","hash":"642445a227e8b702be443958b49901d7c884555f","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/cdn.pug","hash":"9f9a6bdfe1300c46938f9ef818f2bcefc99e1a6e","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/google-tagmanager.pug","hash":"01724665b723aaa1b5fc3a63e3b538970efcd13c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/index.pug","hash":"59cb2c9fce6213536778f3f51126add5fd53d230","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/lightgallery.pug","hash":"7566f8f0cb30139170890eccf3601072f48e72e0","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/pjax.pug","hash":"b5c0c9cf26933621839ab90a4e754e6406341d09","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/aplayer.pug","hash":"1167bc416316139b224057fe54244ff88158b1be","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/back-to-top.pug","hash":"ace7af6f69735441125517aeb9a5257ab7cfaf2b","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/cloud.pug","hash":"8903d1311bf5f68dcc23e520cb4f1e4385aff70d","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/index.pug","hash":"2888bcec128ce5b72236aa794103089b64240689","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/mourn.pug","hash":"3c7741cb35d253a73e2a9ad326ed9e638035102c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/notice.pug","hash":"780a10dbf308022790c58a4d2117dc2f48581531","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/say.pug","hash":"fbb919ae36a9b0ce349ed4b305d19d89231c3dd9","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/scripts/events/config.js","hash":"c52c44c6d00b8fcae05c33293beb5aca7394b5bf","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/scripts/events/index.js","hash":"31111dd9cc1517bec9dc4c590739c492ef2b7efc","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/scripts/events/vendors.js","hash":"3fd51a089e938d48de08a6445112a4eb33d0c272","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/scripts/filters/index.js","hash":"79d58b61e227b63bdd0dd894e6cb7fb5830cc120","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/scripts/helpers/encrypt.js","hash":"6dc249c5845d6440e26772a2efd07713c73df9d0","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/scripts/helpers/engine.js","hash":"ba145729643bbc4a246599ae5cfd1c2b9bd7704e","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/scripts/helpers/index.js","hash":"0284592bf6e585ec6133621699c486ede1b39a70","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/scripts/helpers/yun-config.js","hash":"c4f79e0f6112846500113d17b24867979b4d182c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/hexo-theme-yun.styl","hash":"54b6ec42ae908c25796ea5334dd638441788f4da","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/gallery-decrypt.js","hash":"a3c81112e1957e1df33e795b3c9be194ee7a7648","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/hexo-theme-yun.js","hash":"e8639a10f77ed68d289c7a99750e8f53f9ebb600","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/pjax.js","hash":"8e77ba1d684355cc3db9bedf67816cb55bc9ca3c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/say.js","hash":"f7abbd92b804929bee7650cfbec83479fb5390b3","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/sidebar.js","hash":"f0edb5504c4f472dcab1c574d552fdcab58f76d4","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/utils.js","hash":"655ce9996ae4334f58cecfafc9425e836ce26823","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/assets/icons.json","hash":"77b1354831ece19c786d5d3c4ffe5fe8ae08ab94","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/components/DisplayIcon.vue","hash":"23336545106deecca47fe0e475cb25350a6e551a","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/public/CNAME","hash":"c7ffe7d5488a88dfa38ef3780292c22088d5e8ce","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/public/logo.gif","hash":"a2e7143f1f890f58a3c06b8c0acd7a7a3225022f","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/public/manifest.json","hash":"471057e459e6aeb525e2dc09922e4182ab89683c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/public/yun.svg","hash":"aa027a0a9e7ba96c906b9fd2d9cd3f8018ff2e2d","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/styles/index.styl","hash":"d9430bfc26fd335984c3dfd9c2acee73bdc7eecf","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/.vuepress/styles/palette.styl","hash":"25a57ac820b471bc91c151347a1c1d0cc62767d6","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/guide/README.md","hash":"3f2819a134dadea2c4e0be27fe9f8761771a285f","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/guide/additional-package-support.md","hash":"fa77774e55a122cc9077cba1b16929af121964b7","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/guide/config.md","hash":"0997f5935767eca2b6dc5c167687b70282066378","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/guide/faq.md","hash":"f910f63649baf7f4fd2a6aadab64c34a17ac192b","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/guide/icon.md","hash":"107f7105b2bb90723074d66ddbfc94d0fc9e2b29","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/guide/page.md","hash":"9a39696436aaea20fbb559aca5f6f4a744c0858b","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/docs/en/guide/third-party-support.md","hash":"4e42591c40c5c51e353895fcb0424ac814c0e759","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/post/post-classify.pug","hash":"a71bbbb6575f6969d33e41898cc28fe34b2592bf","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/post/post-copyright.pug","hash":"a2415fb36a0dffbe57bf32cd2cfeace11cbaed6b","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/post/post-edit.pug","hash":"09d21451a8464047777dcbda09c14b1140396dd8","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/post/post-meta.pug","hash":"71fd12c2db9204770afea7db0dbf470cc0b03098","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/post/post-nav.pug","hash":"a951544cfa6127f3284e221cdf6c3e2dcb9801c9","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/post/post-schema.pug","hash":"ec85079174da20c9f608b142e7fda2c28a9b1dac","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/post/reward.pug","hash":"f19b6562f1df71c23dafed15f2f3c9415414e281","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_partial/sidebar/info.pug","hash":"57b04b7781db71b35c17ccc4f9ab8bc46c30e843","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/adsense/google-adsense.pug","hash":"ae63305d776ebec0d88f91197b5c78cdaa401585","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/analytics/busuanzi.pug","hash":"d606071c4c4f1e0df9f55fa6c8e248eb2591c484","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/analytics/google-analytics.pug","hash":"098f9677a9371dbc94bc198a7d85635d43db56eb","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/comments/disqus.pug","hash":"25a2cbdcab67bd3b1e85177f8e5bcb936156b412","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/comments/disqusjs.pug","hash":"4269d6ae618c9faeff8f5864f9ff2b343da54b36","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/comments/github-issues.pug","hash":"2772d0e44da12c261e695e35f265af05f2cd75dc","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/comments/index.pug","hash":"19968f67bf316a54889b2fffbfbe493c5559322e","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/comments/livere.pug","hash":"b81ed4fb8a0ca32ccfb8e22c37ac48e4be1f4152","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/comments/minivaline.pug","hash":"50400c7b29eadfc5e2dc310f032212b678e6818d","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/comments/utterances.pug","hash":"712f893469f258e969806e1b55d0d2ac926761be","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/comments/valine.pug","hash":"6f21a8dd04fd00ee04e321ba166259e92e20c095","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/math/index.pug","hash":"9a61d4923fad7c778f0bf2ce8c81744b126e6a1f","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/math/katex.pug","hash":"20e002f2e73338d317ec6f8e2b8be70378f47d0f","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_third-party/seo/baidu-push.pug","hash":"0669b8c7e54c0a80e1f36e720e299cf0cd1182fe","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/search/algolia-search.pug","hash":"09a15ab356ebde0f9998fe7e39b2f154dea0543a","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/search/index.pug","hash":"05271074172be21c014cd862a25f5112d0b3710c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/layout/_widget/search/local-search.pug","hash":"d2ba600623043b2410f379fd7ba3cc75329ff408","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/button.styl","hash":"3315fc12b1b7659a06120b042a1a2e87a839ebe1","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/card.styl","hash":"66426a03826ab37e94a1667497ce7ffa5a0898f7","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/menu.styl","hash":"b47933a82045f165fb414d7a40135732fb7a7e73","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/scrollbar.styl","hash":"2d735d019b58a1e6fea297e0027c33a4a7bc1858","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/ui.styl","hash":"8e48ea5247c6482afddc430ce1ec3aa276477b1a","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_extend/albums.styl","hash":"1e7c7730c89b6d81da37f6565239679b5075234b","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_extend/girls.styl","hash":"e83c8b1219d0117bc342c40030e106b21245dddf","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_global/dark.styl","hash":"0a499f151df6d4d59fff5346b5d42cd171788bdb","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_global/index.styl","hash":"b0c87153fb535adfc57b91d8db8595f2c8cce8ed","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_global/reset.styl","hash":"85bfc71ba08d3f9959aad3cd1112b5d07e886b99","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_layout/banner.styl","hash":"c076ec7bd0f17ef289b3a198c199879e6f09055c","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_layout/footer.styl","hash":"f8c9fdea73c42913dc11bf68f63fec2ca3b04f7a","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_layout/grid.styl","hash":"3ab663d1bb9dd3639a7adf117e6000a93d093b9e","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_layout/links.styl","hash":"6e6ee87743a1e888dce5682a1168773f6564c875","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_layout/main.styl","hash":"9e88ce9ee2043b72828113c06dd0fcf2ee687611","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_layout/page.styl","hash":"52ff29d8bdc61dedb0a6515dd84cf015db67a499","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_layout/pagination.styl","hash":"da0aa0153ffe72a1164c4acaa1df38c98b708077","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_layout/post.styl","hash":"7c4aa2be9f09e6f170d7cdea0ff1dc9be75866b0","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_mixins/base.styl","hash":"22068203325a4de013b60f504803e5aaeaf54650","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_mixins/helper.styl","hash":"80fcaab47d6a1d202745342e3fc3ee5bf18f39b2","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_variables/_base.styl","hash":"d94e4e978e4d9cdb361a906f2f417787ed86f86a","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_variables/_colors.styl","hash":"7967a8596e7a84208c7440a655b9894fc0276a38","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_widget/back-to-top.styl","hash":"578a29b673da2ed2a0f1c1cc5ec75d92eea27832","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_widget/comment.styl","hash":"048be48d2f236d37b4cc101c7fcd866c6ef46931","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_widget/index.styl","hash":"a740126826a0ae9a1a2860fbb9c8d805d006aad6","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_widget/notice.styl","hash":"1d68860529a4fd8d3f63d2f257ed32b4e0f1167f","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_widget/say.styl","hash":"c47dd38477c08d31e0813610263200322e8f5ebe","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/search/algolia-search.js","hash":"5174bf4bec0e1358e53f9ec7739270eca13846dd","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/search/local-search.js","hash":"e1a6f456b709f58e9133d1b38d213fc6136c12ba","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/ui/banner.js","hash":"17af4d315ab6d503e01069f3b3a561ac514cf316","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/ui/fireworks.js","hash":"7ed58e94596f5a587b56d4adcfa946390559ae53","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/js/ui/mode.js","hash":"abfb79a0d5936230b10dbe1fb5cc1fa148edfe9d","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/post/post-card.styl","hash":"e547b2fb8b108d936083b3d495a79ed5611419e8","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/post/post-codebloack.styl","hash":"c95452abd1799895dab7e9e9353a4f45509edec5","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/post/post-collapse.styl","hash":"6741c225a37e7e121d4159f129b7024402a8eeec","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/post/post-header.styl","hash":"2e674b76b47b3e6226269fe357d8b937b7a007a8","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/post/post-markdown.styl","hash":"db4db1db930fda3f7735d2b60021fd7843ff3322","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/post/post-nav.styl","hash":"4d2a08142a2ea83fae5cff0daa4f2bddf58a7a57","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/post/post-reward.styl","hash":"4468fabe6288110a6a38b546a59c438849edc62d","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/sidebar/hamburger.styl","hash":"0fa240e8a71fdad14d3fd6b3fd49cf697d4c8153","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/sidebar/sidebar-nav.styl","hash":"523e765158652f86ab4f70f0138c3746782b24e5","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/sidebar/sidebar-toc.styl","hash":"adf311e802fb38e818f49512a43a2d546959d6d0","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/sidebar/sidebar.styl","hash":"21b2532c943e06bae70ed2a6b341b4816ce55898","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_components/sidebar/site-overview.styl","hash":"23e42f93aa236a5212450baf2151ed64176c91c2","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_widget/search/algolia-search.styl","hash":"69916b23d54859160c4fda5ee809b8375fc56151","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_widget/search/index.styl","hash":"82370e7ae17e52a7185a1e83bece91f0515486df","modified":1600602145000},{"_id":"themes/hexo-theme-yun-dev/source/css/_widget/search/local-search.styl","hash":"bcb8e5d593d49e370312e17eadf9f1e13aa22829","modified":1600602145000},{"_id":"public/about/index.html","hash":"8df97e1cd0cfac71b830a4ca82dde13c0e34e2e0","modified":1600689125064},{"_id":"public/archives/index.html","hash":"a1cb061b4b97d0a41f59350c252c15c475bd72a3","modified":1600689125064},{"_id":"public/categories/index.html","hash":"d794eef931b4afb590622e90fae6e0e7175a2d88","modified":1600689125064},{"_id":"public/contact/index.html","hash":"410416edc7dd3d334804c7ee34b0985f21db4c96","modified":1600689125064},{"_id":"public/friends/index.html","hash":"51d08dd1bd37fb5da05c56da4e0b66398e8cd163","modified":1600689125064},{"_id":"public/tags/index.html","hash":"b0a55cc0abfd36511ed50636be1362bb19250ada","modified":1600689125064},{"_id":"public/archives/2020/index.html","hash":"fe9fb4759aac46f1ec0de233f6c36bd931d8d8b5","modified":1600689125064},{"_id":"public/archives/2020/09/index.html","hash":"b86d8d4c8d251e69971c1817f80441dad6e6fa59","modified":1600689125064},{"_id":"public/categories/编程语言/index.html","hash":"15938715158aa42362b5cd2133e23622254f49af","modified":1600689125064},{"_id":"public/tags/TypeScript/index.html","hash":"37b74721f65db26ac1ed67eb88e7bbcdc06f9404","modified":1600689125064},{"_id":"public/2020/09/16/typescript-3/index.html","hash":"8f149e3cf7c7198eca9ee464d147f93f25ecaecf","modified":1600689125064},{"_id":"public/2020/09/16/typescript-2/index.html","hash":"7b873817d59dc73ef1db89c69b2c151c800c56d0","modified":1600689125064},{"_id":"public/2020/09/16/typescript-1/index.html","hash":"02a888516f64638de55bf98ded83495db7f0f923","modified":1600689125064},{"_id":"public/2020/09/08/hello-world/index.html","hash":"9a11848fc4e8d7d77e496ef4d8edf8a20e5ff401","modified":1600689125064},{"_id":"public/index.html","hash":"753b5c6f166b1360f4ee3c35ab5bbe69fc11b8f7","modified":1600689125064},{"_id":"public/Yun.png","hash":"b8ae426fa5dd7579d23d189c222641d812c51c0a","modified":1600689125064},{"_id":"public/yun.ico","hash":"5d63418cd650d1881d4b6507f35b9f9df766020e","modified":1600689125064},{"_id":"public/yun.svg","hash":"aa027a0a9e7ba96c906b9fd2d9cd3f8018ff2e2d","modified":1600689125064},{"_id":"public/js/gallery-decrypt.js","hash":"a3c81112e1957e1df33e795b3c9be194ee7a7648","modified":1600689125064},{"_id":"public/js/hexo-theme-yun.js","hash":"e8639a10f77ed68d289c7a99750e8f53f9ebb600","modified":1600689125064},{"_id":"public/js/pjax.js","hash":"8e77ba1d684355cc3db9bedf67816cb55bc9ca3c","modified":1600689125064},{"_id":"public/js/say.js","hash":"f7abbd92b804929bee7650cfbec83479fb5390b3","modified":1600689125064},{"_id":"public/js/sidebar.js","hash":"f0edb5504c4f472dcab1c574d552fdcab58f76d4","modified":1600689125064},{"_id":"public/js/utils.js","hash":"655ce9996ae4334f58cecfafc9425e836ce26823","modified":1600689125064},{"_id":"public/js/search/algolia-search.js","hash":"5174bf4bec0e1358e53f9ec7739270eca13846dd","modified":1600689125064},{"_id":"public/js/search/local-search.js","hash":"e1a6f456b709f58e9133d1b38d213fc6136c12ba","modified":1600689125064},{"_id":"public/js/ui/banner.js","hash":"17af4d315ab6d503e01069f3b3a561ac514cf316","modified":1600689125064},{"_id":"public/js/ui/fireworks.js","hash":"5191acacfc081e87789cbb2fe86548569042e094","modified":1600689125064},{"_id":"public/js/ui/mode.js","hash":"abfb79a0d5936230b10dbe1fb5cc1fa148edfe9d","modified":1600689125064},{"_id":"public/css/hexo-theme-yun.css","hash":"ab3a6382dae6da4b164602e5757f8441dbec5f0f","modified":1600689125064}],"Category":[{"name":"编程语言","_id":"ckfcgz6380005ijobgfmfb7ta"}],"Data":[{"_id":"friends","data":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}],"Page":[{"title":"about","date":"2020-09-08T12:21:23.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-09-08 20:21:23\ntype: \"about\"\nlayout: \"about\"\n---\n","updated":"2020-09-09T06:14:37.990Z","path":"about/index.html","comments":1,"_id":"ckfcgz62s0000ijob9f382izk","content":"","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":""},{"title":"archives","date":"2020-09-08T12:21:09.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2020-09-08 20:21:09\ntype: \"archives\"\nlayout: \"archives\"\n---\n","updated":"2020-09-09T06:16:26.249Z","path":"archives/index.html","comments":1,"_id":"ckfcgz6330002ijob8jsk9cf9","content":"","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":""},{"title":"categories","date":"2020-09-08T12:20:55.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-09-08 20:20:55\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2020-09-09T06:14:02.422Z","path":"categories/index.html","comments":1,"_id":"ckfcgz6370004ijobdwm42jzr","content":"","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":""},{"title":"contact","date":"2020-09-09T06:26:39.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-09-09 14:26:39\ntype: \"contact\"\nlayout: \"contact\"\n---\n","updated":"2020-09-09T06:27:12.255Z","path":"contact/index.html","comments":1,"_id":"ckfcgz63b0007ijob2cme8wqc","content":"","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":""},{"title":"friends","date":"2020-09-09T06:15:31.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2020-09-09 14:15:31\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2020-09-09T06:15:56.314Z","path":"friends/index.html","comments":1,"_id":"ckfcgz63c0008ijobdsy646ro","content":"","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":""},{"title":"tags","date":"2020-09-08T12:20:09.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-09-08 20:20:09\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2020-09-09T06:14:19.708Z","path":"tags/index.html","comments":1,"_id":"ckfcgz63d0009ijobck6tbhiu","content":"","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2020-09-08T10:04:41.602Z","updated":"2020-09-08T10:04:41.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfcgz62y0001ijobamjj54a1","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"基础类型","comments":1,"_content":"### 介绍\n\n为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n### 布尔值\n\n最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。\n``` typescript\nlet isDone: boolean = false;\n```\n### 数字\n\n和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\n``` typescript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\n```\n### 字符串\n\nJavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ \"）或单引号（'）表示字符串。\n``` typescript\nlet name: string = \"bob\";\nname = \"smith\";\n```\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式\n``` typescript\nlet name: string = `Gene`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`;\n```\n这与下面定义sentence的方式效果相同：\n``` typescript\nlet sentence: string = \"Hello, my name is \" + name + \".\\n\\n\" +\n    \"I'll be \" + (age + 1) + \" years old next month.\";\n```\n### 数组\n\nTypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：\n``` typescript\nlet list: number[] = [1, 2, 3];\n```\n第二种方式是使用数组泛型，Array<元素类型>：\n``` typescript\nlet list: Array<number> = [1, 2, 3];\n```\n### 元组 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。\n``` typescript\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = ['hello', 10]; // OK\n// Initialize it incorrectly\nx = [10, 'hello']; // Error\n```\n当访问一个已知索引的元素，会得到正确的类型：\n``` typescript\nconsole.log(x[0].substr(1)); // OK\nconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr'\n```\n当访问一个越界的元素，会使用联合类型替代：\n``` typescript\nx[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true; // Error, 布尔不是(string | number)类型\n```\n联合类型是高级主题，我们会在以后的章节里讨论它。\n### 枚举\n\nenum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n``` typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```\n默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：\n``` typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green;\n```\n或者，全部都采用手动赋值：\n``` typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;\n```\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：\n``` typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2];\n\nconsole.log(colorName);  // 显示'Green'因为上面代码里它的值是2\n```\n### Any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：\n``` typescript\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n```\n在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：\n``` typescript\nlet notSure: any = 4;\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)\n\nlet prettySure: Object = 4;\nprettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.\n```\n当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n``` typescript\nlet list: any[] = [1, true, \"free\"];\n\nlist[1] = 100;\n```\n### Void\n\n某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n``` typescript\nfunction warnUser(): void {\n    console.log(\"This is my warning message\");\n}\n```\n声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：\n``` typescript\nlet unusable: void = undefined;\n```\n### Null 和 Undefined\n\nTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：\n``` typescript\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n```\n默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。\n\n然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。\n\n> 注意：我们鼓励尽可能地使用--strictNullChecks，但在本手册里我们假设这个标记是关闭的。\n\n### Never\n\nnever类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。\n\nnever类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。\n\n下面是一些返回never类型的函数：\n``` typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n    return error(\"Something failed\");\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n```\n### Object\n\nobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。\n\n使用object类型，就可以更好的表示像Object.create这样的API。例如：\n``` typescript\ndeclare function create(o: object | null): void;\n\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n```\n### 类型断言\n\n有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n``` typescript\nlet someValue: any = \"this is a string\";\n\nlet strLength: number = (<string>someValue).length;\n```\n另一个为as语法：\n``` typescript\nlet someValue: any = \"this is a string\";\n\nlet strLength: number = (someValue as string).length;\n```\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。\n关于let\n\n你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。","source":"_posts/typescript-1.md","raw":"---\ntitle: 基础类型\ncategories: 编程语言\ntags: TypeScript\ncomments: true\n---\n### 介绍\n\n为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。\n### 布尔值\n\n最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。\n``` typescript\nlet isDone: boolean = false;\n```\n### 数字\n\n和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。\n``` typescript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\n```\n### 字符串\n\nJavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ \"）或单引号（'）表示字符串。\n``` typescript\nlet name: string = \"bob\";\nname = \"smith\";\n```\n你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式\n``` typescript\nlet name: string = `Gene`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${ name }.\n\nI'll be ${ age + 1 } years old next month.`;\n```\n这与下面定义sentence的方式效果相同：\n``` typescript\nlet sentence: string = \"Hello, my name is \" + name + \".\\n\\n\" +\n    \"I'll be \" + (age + 1) + \" years old next month.\";\n```\n### 数组\n\nTypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：\n``` typescript\nlet list: number[] = [1, 2, 3];\n```\n第二种方式是使用数组泛型，Array<元素类型>：\n``` typescript\nlet list: Array<number> = [1, 2, 3];\n```\n### 元组 Tuple\n\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。\n``` typescript\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = ['hello', 10]; // OK\n// Initialize it incorrectly\nx = [10, 'hello']; // Error\n```\n当访问一个已知索引的元素，会得到正确的类型：\n``` typescript\nconsole.log(x[0].substr(1)); // OK\nconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr'\n```\n当访问一个越界的元素，会使用联合类型替代：\n``` typescript\nx[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型\n\nconsole.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString\n\nx[6] = true; // Error, 布尔不是(string | number)类型\n```\n联合类型是高级主题，我们会在以后的章节里讨论它。\n### 枚举\n\nenum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\n``` typescript\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;\n```\n默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：\n``` typescript\nenum Color {Red = 1, Green, Blue}\nlet c: Color = Color.Green;\n```\n或者，全部都采用手动赋值：\n``` typescript\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;\n```\n枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：\n``` typescript\nenum Color {Red = 1, Green, Blue}\nlet colorName: string = Color[2];\n\nconsole.log(colorName);  // 显示'Green'因为上面代码里它的值是2\n```\n### Any\n\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：\n``` typescript\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // okay, definitely a boolean\n```\n在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：\n``` typescript\nlet notSure: any = 4;\nnotSure.ifItExists(); // okay, ifItExists might exist at runtime\nnotSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)\n\nlet prettySure: Object = 4;\nprettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.\n```\n当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：\n``` typescript\nlet list: any[] = [1, true, \"free\"];\n\nlist[1] = 100;\n```\n### Void\n\n某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：\n``` typescript\nfunction warnUser(): void {\n    console.log(\"This is my warning message\");\n}\n```\n声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：\n``` typescript\nlet unusable: void = undefined;\n```\n### Null 和 Undefined\n\nTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：\n``` typescript\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\n```\n默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。\n\n然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。\n\n> 注意：我们鼓励尽可能地使用--strictNullChecks，但在本手册里我们假设这个标记是关闭的。\n\n### Never\n\nnever类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。\n\nnever类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。\n\n下面是一些返回never类型的函数：\n``` typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n    return error(\"Something failed\");\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n```\n### Object\n\nobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。\n\n使用object类型，就可以更好的表示像Object.create这样的API。例如：\n``` typescript\ndeclare function create(o: object | null): void;\n\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\n\ncreate(42); // Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n```\n### 类型断言\n\n有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n\n通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。\n\n类型断言有两种形式。 其一是“尖括号”语法：\n``` typescript\nlet someValue: any = \"this is a string\";\n\nlet strLength: number = (<string>someValue).length;\n```\n另一个为as语法：\n``` typescript\nlet someValue: any = \"this is a string\";\n\nlet strLength: number = (someValue as string).length;\n```\n两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。\n关于let\n\n你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。","slug":"typescript-1","published":1,"date":"2020-09-16T08:49:43.545Z","updated":"2020-09-16T09:27:41.149Z","layout":"post","photos":[],"link":"","_id":"ckfcgz6340003ijob59f4crds","content":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0xf00d</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b1010</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o744</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;bob&quot;</span>;</span><br><span class=\"line\">name = <span class=\"string\">&quot;smith&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">`Gene`</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age: <span class=\"built_in\">number</span> = <span class=\"number\">37</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123; name &#125;</span>.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">I&#x27;ll be <span class=\"subst\">$&#123; age + <span class=\"number\">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>\n<p>这与下面定义sentence的方式效果相同：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;Hello, my name is &quot;</span> + name + <span class=\"string\">&quot;.\\n\\n&quot;</span> +</span><br><span class=\"line\">    <span class=\"string\">&quot;I&#x27;ll be &quot;</span> + (age + <span class=\"number\">1</span>) + <span class=\"string\">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"元组-Tuple\"><a href=\"#元组-Tuple\" class=\"headerlink\" title=\"元组 Tuple\"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Declare a tuple type</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br><span class=\"line\"><span class=\"comment\">// Initialize it</span></span><br><span class=\"line\">x = [<span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"number\">10</span>]; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"comment\">// Initialize it incorrectly</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">&#x27;hello&#x27;</span>]; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个已知索引的元素，会得到正确的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)); <span class=\"comment\">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个越界的元素，会使用联合类型替代：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;world&#x27;</span>; <span class=\"comment\">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()); <span class=\"comment\">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span>; <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>或者，全部都采用手动赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green = <span class=\"number\">2</span>, Blue = <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName);  <span class=\"comment\">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Any\"><a href=\"#Any\" class=\"headerlink\" title=\"Any\"></a>Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">notSure = <span class=\"string\">&quot;maybe a string instead&quot;</span>;</span><br><span class=\"line\">notSure = <span class=\"literal\">false</span>; <span class=\"comment\">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>\n<p>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">notSure.ifItExists(); <span class=\"comment\">// okay, ifItExists might exist at runtime</span></span><br><span class=\"line\">notSure.toFixed(); <span class=\"comment\">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> prettySure: <span class=\"built_in\">Object</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">prettySure.toFixed(); <span class=\"comment\">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>\n<p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">&quot;free&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Void\"><a href=\"#Void\" class=\"headerlink\" title=\"Void\"></a>Void</h3><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;This is my warning message&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusable: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h3><p>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Not much else we can assign to these variables!</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p>\n<p>然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。</p>\n<blockquote>\n<p>注意：我们鼓励尽可能地使用–strictNullChecks，但在本手册里我们假设这个标记是关闭的。</p>\n</blockquote>\n<h3 id=\"Never\"><a href=\"#Never\" class=\"headerlink\" title=\"Never\"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p>\n<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p>\n<p>下面是一些返回never类型的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error(<span class=\"string\">&quot;Something failed&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>\n<p>使用object类型，就可以更好的表示像Object.create这样的API。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: <span class=\"built_in\">object</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">create(&#123; prop: <span class=\"number\">0</span> &#125;); <span class=\"comment\">// OK</span></span><br><span class=\"line\">create(<span class=\"literal\">null</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">create(<span class=\"number\">42</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"literal\">false</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"literal\">undefined</span>); <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p>\n<p>类型断言有两种形式。 其一是“尖括号”语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>\n<p>另一个为as语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length;</span><br></pre></td></tr></table></figure>\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。<br>关于let</p>\n<p>你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。</p>\n","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>\n<h3 id=\"布尔值\"><a href=\"#布尔值\" class=\"headerlink\" title=\"布尔值\"></a>布尔值</h3><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0xf00d</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b1010</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o744</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ “）或单引号（’）表示字符串。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;bob&quot;</span>;</span><br><span class=\"line\">name = <span class=\"string\">&quot;smith&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">`Gene`</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age: <span class=\"built_in\">number</span> = <span class=\"number\">37</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123; name &#125;</span>.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">I&#x27;ll be <span class=\"subst\">$&#123; age + <span class=\"number\">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>\n<p>这与下面定义sentence的方式效果相同：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sentence: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;Hello, my name is &quot;</span> + name + <span class=\"string\">&quot;.\\n\\n&quot;</span> +</span><br><span class=\"line\">    <span class=\"string\">&quot;I&#x27;ll be &quot;</span> + (age + <span class=\"number\">1</span>) + <span class=\"string\">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<h3 id=\"元组-Tuple\"><a href=\"#元组-Tuple\" class=\"headerlink\" title=\"元组 Tuple\"></a>元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Declare a tuple type</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br><span class=\"line\"><span class=\"comment\">// Initialize it</span></span><br><span class=\"line\">x = [<span class=\"string\">&#x27;hello&#x27;</span>, <span class=\"number\">10</span>]; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"comment\">// Initialize it incorrectly</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">&#x27;hello&#x27;</span>]; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个已知索引的元素，会得到正确的类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)); <span class=\"comment\">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>当访问一个越界的元素，会使用联合类型替代：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">&#x27;world&#x27;</span>; <span class=\"comment\">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()); <span class=\"comment\">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class=\"line\"></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span>; <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n<p>联合类型是高级主题，我们会在以后的章节里讨论它。</p>\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;Red, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>或者，全部都采用手动赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green = <span class=\"number\">2</span>, Blue = <span class=\"number\">4</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;Red = <span class=\"number\">1</span>, Green, Blue&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName);  <span class=\"comment\">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Any\"><a href=\"#Any\" class=\"headerlink\" title=\"Any\"></a>Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">notSure = <span class=\"string\">&quot;maybe a string instead&quot;</span>;</span><br><span class=\"line\">notSure = <span class=\"literal\">false</span>; <span class=\"comment\">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>\n<p>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">notSure.ifItExists(); <span class=\"comment\">// okay, ifItExists might exist at runtime</span></span><br><span class=\"line\">notSure.toFixed(); <span class=\"comment\">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> prettySure: <span class=\"built_in\">Object</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">prettySure.toFixed(); <span class=\"comment\">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>\n<p>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">&quot;free&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Void\"><a href=\"#Void\" class=\"headerlink\" title=\"Void\"></a>Void</h3><p>某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;This is my warning message&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusable: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Null-和-Undefined\"><a href=\"#Null-和-Undefined\" class=\"headerlink\" title=\"Null 和 Undefined\"></a>Null 和 Undefined</h3><p>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Not much else we can assign to these variables!</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p>\n<p>然而，当你指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。</p>\n<blockquote>\n<p>注意：我们鼓励尽可能地使用–strictNullChecks，但在本手册里我们假设这个标记是关闭的。</p>\n</blockquote>\n<h3 id=\"Never\"><a href=\"#Never\" class=\"headerlink\" title=\"Never\"></a>Never</h3><p>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p>\n<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p>\n<p>下面是一些返回never类型的函数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> error(<span class=\"string\">&quot;Something failed&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回never的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h3><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>\n<p>使用object类型，就可以更好的表示像Object.create这样的API。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: <span class=\"built_in\">object</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">create(&#123; prop: <span class=\"number\">0</span> &#125;); <span class=\"comment\">// OK</span></span><br><span class=\"line\">create(<span class=\"literal\">null</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">create(<span class=\"number\">42</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"literal\">false</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"literal\">undefined</span>); <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><p>有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p>\n<p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p>\n<p>类型断言有两种形式。 其一是“尖括号”语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>\n<p>另一个为as语法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length;</span><br></pre></td></tr></table></figure>\n<p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。<br>关于let</p>\n<p>你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。</p>\n"},{"title":"变量声明","comments":1,"_content":"### 变量声明\n\nlet和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。\n\n因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。\n\n如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 var声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n### var 声明\n\n一直以来我们都是通过var关键字定义JavaScript变量。\n``` typescript\nvar a = 10;\n```\n大家都能理解，这里定义了一个名为a值为10的变量。\n\n我们也可以在函数内部定义变量：\n``` typescript\nfunction f() {\n    var message = \"Hello, world!\";\n\n    return message;\n}\n```\n并且我们也可以在其它函数内部访问相同的变量。\n``` typescript\nfunction f() {\n    var a = 10;\n    return function g() {\n        var b = a + 1;\n        return b;\n    }\n}\n\nvar g = f();\ng(); // returns 11;\n```\n上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。\n``` typescript\nfunction f() {\n    var a = 1;\n\n    a = 2;\n    var b = g();\n    a = 3;\n\n    return b;\n\n    function g() {\n        return a;\n    }\n}\n\nf(); // returns 2\n```\n### 作用域规则\n\n对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：\n``` typescript\nfunction f(shouldInitialize: boolean) {\n    if (shouldInitialize) {\n        var x = 10;\n    }\n\n    return x;\n}\n\nf(true);  // returns '10'\nf(false); // returns 'undefined'\n```\n有些读者可能要多看几遍这个例子。 变量 x是定义在*if语句里面*，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为* var作用域或函数作用域*。 函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n``` typescript\nfunction sumMatrix(matrix: number[][]) {\n    var sum = 0;\n    for (var i = 0; i < matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (var i = 0; i < currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n```\n这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n捕获变量怪异之处\n\n快速的猜一下下面的代码会返回什么：\n``` typescript\nfor (var i = 0; i < 10; i++) {\n    setTimeout(function() { console.log(i); }, 100 * i);\n}\n```\n介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。\n\n好吧，看一下结果：\n``` typescript\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：\n``` typescript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n还记得我们上面提到的捕获变量吗？\n\n> 我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。\n\n让我们花点时间思考一下这是为什么。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出 10！\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：\n``` typescript\nfor (var i = 0; i < 10; i++) {\n    // capture the current state of 'i'\n    // by invoking a function with its current value\n    (function(i) {\n        setTimeout(function() { console.log(i); }, 100 * i);\n    })(i);\n}\n```\n这种奇怪的形式我们已经司空见惯了。 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。\n### let 声明\n\n现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外， let与var的写法一致。\n``` typescript\nlet hello = \"Hello!\";\n```\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n### 块作用域\n\n当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。\n``` typescript\nfunction f(input: boolean) {\n    let a = 100;\n\n    if (input) {\n        // Still okay to reference 'a'\n        let b = a + 1;\n        return b;\n    }\n\n    // Error: 'b' doesn't exist here\n    return b;\n}\n```\n这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。\n\n在catch语句里声明的变量也具有同样的作用域规则。\n``` typescript\ntry {\n    throw \"oh no!\";\n}\ncatch (e) {\n    console.log(\"Oh well.\");\n}\n\n// Error: 'e' doesn't exist here\nconsole.log(e);\n```\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。\n``` typescript\na++; // illegal to use 'a' before it's declared;\nlet a;\n```\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。\n``` typescript\nfunction foo() {\n    // okay to capture 'a'\n    return a;\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo();\n\nlet a;\n```\n关于暂时性死区的更多信息，查看这里Mozilla Developer Network.\n### 重定义及屏蔽\n\n我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。\n``` typescript\nfunction f(x) {\n    var x;\n    var x;\n\n    if (true) {\n        var x;\n    }\n}\n```\n在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， let声明就不会这么宽松了。\n``` typescript\nlet x = 10;\nlet x = 20; // 错误，不能在1个作用域里多次声明`x`\n```\n并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。\n``` typescript\nfunction f(x) {\n    let x = 100; // error: interferes with parameter declaration\n}\n\nfunction g() {\n    let x = 100;\n    var x = 100; // error: can't have both declarations of 'x'\n}\n```\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n``` typescript\nfunction f(condition, x) {\n    if (condition) {\n        let x = 100;\n        return x;\n    }\n\n    return x;\n}\n\nf(false, 0); // returns 0\nf(true, 0);  // returns 100\n```\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。\n``` typescript\nfunction sumMatrix(matrix: number[][]) {\n    let sum = 0;\n    for (let i = 0; i < matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (let i = 0; i < currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n```\n这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。\n\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。\n块级作用域变量的获取\n\n在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n``` typescript\nfunction theCityThatAlwaysSleeps() {\n    let getCity;\n\n    if (true) {\n        let city = \"Seattle\";\n        getCity = function() {\n            return city;\n        }\n    }\n\n    return getCity();\n}\n```\n因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。\n\n回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。\n\n当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。\n``` typescript\nfor (let i = 0; i < 10 ; i++) {\n    setTimeout(function() {console.log(i); }, 100 * i);\n}\n```\n会输出与预料一致的结果：\n``` typescript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n### const 声明\n\nconst 声明是声明变量的另一种方式。\n\nconst numLivesForCat = 9;\n\n它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是不可变的。\n``` typescript\nconst numLivesForCat = 9;\nconst kitty = {\n    name: \"Aurora\",\n    numLives: numLivesForCat,\n}\n\n// Error\nkitty = {\n    name: \"Danielle\",\n    numLives: numLivesForCat\n};\n\n// all \"okay\"\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;\n```\n除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。\n### let vs. const\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。\n\n跟据你的自己判断，如果合适的话，与团队成员商议一下。\n\n这个手册大部分地方都使用了let声明。\n解构\n\nAnother TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 the article on the Mozilla Developer Network。 本章，我们将给出一个简短的概述。\n解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n``` typescript\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n```\n这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：\n``` typescript\nfirst = input[0];\nsecond = input[1];\n```\n解构作用于已声明的变量会更好：\n``` typescript\n// swap variables\n[first, second] = [second, first];\n```\n作用于函数参数：\n``` typescript\nfunction f([first, second]: [number, number]) {\n    console.log(first);\n    console.log(second);\n}\nf(input);\n```\n你可以在数组里使用...语法创建剩余变量：\n``` typescript\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n```\n当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：\n``` typescript\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n或其它元素：\n``` typescript\nlet [, second, , fourth] = [1, 2, 3, 4];\n```\n对象解构\n\n你也可以解构对象：\n``` typescript\nlet o = {\n    a: \"foo\",\n    b: 12,\n    c: \"bar\"\n};\nlet { a, b } = o;\n```\n这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。\n\n就像数组解构，你可以用没有声明的赋值：\n``` typescript\n({ a, b } = { a: \"baz\", b: 101 });\n```\n注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。\n\n你可以在对象里使用...语法创建剩余变量：\n``` typescript\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n### 属性重命名\n\n你也可以给属性以不同的名字：\n``` typescript\nlet { a: newName1, b: newName2 } = o;\n```\n这里的语法开始变得混乱。 你可以将 a: newName1 读做 \"a 作为 newName1\"。 方向是从左到右，好像你写成了以下样子：\n``` typescript\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。\n``` typescript\nlet {a, b}: {a: string, b: number} = o;\n```\n### 默认值\n\n默认值可以让你在属性为 undefined 时使用缺省值：\n``` typescript\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\n```\n现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。\n函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n``` typescript\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n    // ...\n}\n```\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n``` typescript\nfunction f({ a=\"\", b=0 } = {}): void {\n    // ...\n}\nf();\n```\n> 上面的代码是一个类型推断的例子，将在本手册后文介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：\n``` typescript\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n    // ...\n}\nf({ a: \"yes\" }); // ok, default b = 0\nf(); // ok, default to {a: \"\"}, which then defaults b = 0\nf({}); // error, 'a' is required if you supply an argument\n```\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。\n展开\n\n展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：\n``` typescript\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n``` typescript\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { ...defaults, food: \"rich\" };\n```\nsearch的值为{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：\n``` typescript\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { food: \"rich\", ...defaults };\n```\n那么，defaults里的food属性会重写food: \"rich\"，在这里这并不是我们想要的结果。\n\n对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：\n``` typescript\nclass C {\n  p = 12;\n  m() {\n  }\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n```\n其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。 ","source":"_posts/typescript-2.md","raw":"---\ntitle: 变量声明\ncategories: 编程语言\ntags: TypeScript\ncomments: true\n---\n### 变量声明\n\nlet和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。\n\n因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。\n\n如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 var声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n### var 声明\n\n一直以来我们都是通过var关键字定义JavaScript变量。\n``` typescript\nvar a = 10;\n```\n大家都能理解，这里定义了一个名为a值为10的变量。\n\n我们也可以在函数内部定义变量：\n``` typescript\nfunction f() {\n    var message = \"Hello, world!\";\n\n    return message;\n}\n```\n并且我们也可以在其它函数内部访问相同的变量。\n``` typescript\nfunction f() {\n    var a = 10;\n    return function g() {\n        var b = a + 1;\n        return b;\n    }\n}\n\nvar g = f();\ng(); // returns 11;\n```\n上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。\n``` typescript\nfunction f() {\n    var a = 1;\n\n    a = 2;\n    var b = g();\n    a = 3;\n\n    return b;\n\n    function g() {\n        return a;\n    }\n}\n\nf(); // returns 2\n```\n### 作用域规则\n\n对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：\n``` typescript\nfunction f(shouldInitialize: boolean) {\n    if (shouldInitialize) {\n        var x = 10;\n    }\n\n    return x;\n}\n\nf(true);  // returns '10'\nf(false); // returns 'undefined'\n```\n有些读者可能要多看几遍这个例子。 变量 x是定义在*if语句里面*，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为* var作用域或函数作用域*。 函数参数也使用函数作用域。\n\n这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n``` typescript\nfunction sumMatrix(matrix: number[][]) {\n    var sum = 0;\n    for (var i = 0; i < matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (var i = 0; i < currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n```\n这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n捕获变量怪异之处\n\n快速的猜一下下面的代码会返回什么：\n``` typescript\nfor (var i = 0; i < 10; i++) {\n    setTimeout(function() { console.log(i); }, 100 * i);\n}\n```\n介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。\n\n好吧，看一下结果：\n``` typescript\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n```\n很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：\n``` typescript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n还记得我们上面提到的捕获变量吗？\n\n> 我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。\n\n让我们花点时间思考一下这是为什么。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出 10！\n\n一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：\n``` typescript\nfor (var i = 0; i < 10; i++) {\n    // capture the current state of 'i'\n    // by invoking a function with its current value\n    (function(i) {\n        setTimeout(function() { console.log(i); }, 100 * i);\n    })(i);\n}\n```\n这种奇怪的形式我们已经司空见惯了。 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。\n### let 声明\n\n现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外， let与var的写法一致。\n``` typescript\nlet hello = \"Hello!\";\n```\n主要的区别不在语法上，而是语义，我们接下来会深入研究。\n### 块作用域\n\n当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。\n``` typescript\nfunction f(input: boolean) {\n    let a = 100;\n\n    if (input) {\n        // Still okay to reference 'a'\n        let b = a + 1;\n        return b;\n    }\n\n    // Error: 'b' doesn't exist here\n    return b;\n}\n```\n这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。\n\n在catch语句里声明的变量也具有同样的作用域规则。\n``` typescript\ntry {\n    throw \"oh no!\";\n}\ncatch (e) {\n    console.log(\"Oh well.\");\n}\n\n// Error: 'e' doesn't exist here\nconsole.log(e);\n```\n拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。\n``` typescript\na++; // illegal to use 'a' before it's declared;\nlet a;\n```\n注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。\n``` typescript\nfunction foo() {\n    // okay to capture 'a'\n    return a;\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo();\n\nlet a;\n```\n关于暂时性死区的更多信息，查看这里Mozilla Developer Network.\n### 重定义及屏蔽\n\n我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。\n``` typescript\nfunction f(x) {\n    var x;\n    var x;\n\n    if (true) {\n        var x;\n    }\n}\n```\n在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， let声明就不会这么宽松了。\n``` typescript\nlet x = 10;\nlet x = 20; // 错误，不能在1个作用域里多次声明`x`\n```\n并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。\n``` typescript\nfunction f(x) {\n    let x = 100; // error: interferes with parameter declaration\n}\n\nfunction g() {\n    let x = 100;\n    var x = 100; // error: can't have both declarations of 'x'\n}\n```\n并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n``` typescript\nfunction f(condition, x) {\n    if (condition) {\n        let x = 100;\n        return x;\n    }\n\n    return x;\n}\n\nf(false, 0); // returns 0\nf(true, 0);  // returns 100\n```\n在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。\n``` typescript\nfunction sumMatrix(matrix: number[][]) {\n    let sum = 0;\n    for (let i = 0; i < matrix.length; i++) {\n        var currentRow = matrix[i];\n        for (let i = 0; i < currentRow.length; i++) {\n            sum += currentRow[i];\n        }\n    }\n\n    return sum;\n}\n```\n这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。\n\n通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。\n块级作用域变量的获取\n\n在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n``` typescript\nfunction theCityThatAlwaysSleeps() {\n    let getCity;\n\n    if (true) {\n        let city = \"Seattle\";\n        getCity = function() {\n            return city;\n        }\n    }\n\n    return getCity();\n}\n```\n因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。\n\n回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。\n\n当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。\n``` typescript\nfor (let i = 0; i < 10 ; i++) {\n    setTimeout(function() {console.log(i); }, 100 * i);\n}\n```\n会输出与预料一致的结果：\n``` typescript\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n```\n### const 声明\n\nconst 声明是声明变量的另一种方式。\n\nconst numLivesForCat = 9;\n\n它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。\n\n这很好理解，它们引用的值是不可变的。\n``` typescript\nconst numLivesForCat = 9;\nconst kitty = {\n    name: \"Aurora\",\n    numLives: numLivesForCat,\n}\n\n// Error\nkitty = {\n    name: \"Danielle\",\n    numLives: numLivesForCat\n};\n\n// all \"okay\"\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;\n```\n除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。\n### let vs. const\n\n现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。\n\n使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。\n\n跟据你的自己判断，如果合适的话，与团队成员商议一下。\n\n这个手册大部分地方都使用了let声明。\n解构\n\nAnother TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 the article on the Mozilla Developer Network。 本章，我们将给出一个简短的概述。\n解构数组\n\n最简单的解构莫过于数组的解构赋值了：\n``` typescript\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n```\n这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：\n``` typescript\nfirst = input[0];\nsecond = input[1];\n```\n解构作用于已声明的变量会更好：\n``` typescript\n// swap variables\n[first, second] = [second, first];\n```\n作用于函数参数：\n``` typescript\nfunction f([first, second]: [number, number]) {\n    console.log(first);\n    console.log(second);\n}\nf(input);\n```\n你可以在数组里使用...语法创建剩余变量：\n``` typescript\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n```\n当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：\n``` typescript\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n或其它元素：\n``` typescript\nlet [, second, , fourth] = [1, 2, 3, 4];\n```\n对象解构\n\n你也可以解构对象：\n``` typescript\nlet o = {\n    a: \"foo\",\n    b: 12,\n    c: \"bar\"\n};\nlet { a, b } = o;\n```\n这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。\n\n就像数组解构，你可以用没有声明的赋值：\n``` typescript\n({ a, b } = { a: \"baz\", b: 101 });\n```\n注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。\n\n你可以在对象里使用...语法创建剩余变量：\n``` typescript\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n### 属性重命名\n\n你也可以给属性以不同的名字：\n``` typescript\nlet { a: newName1, b: newName2 } = o;\n```\n这里的语法开始变得混乱。 你可以将 a: newName1 读做 \"a 作为 newName1\"。 方向是从左到右，好像你写成了以下样子：\n``` typescript\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。\n``` typescript\nlet {a, b}: {a: string, b: number} = o;\n```\n### 默认值\n\n默认值可以让你在属性为 undefined 时使用缺省值：\n``` typescript\nfunction keepWholeObject(wholeObject: { a: string, b?: number }) {\n    let { a, b = 1001 } = wholeObject;\n}\n```\n现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。\n函数声明\n\n解构也能用于函数声明。 看以下简单的情况：\n``` typescript\ntype C = { a: string, b?: number }\nfunction f({ a, b }: C): void {\n    // ...\n}\n```\n但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n``` typescript\nfunction f({ a=\"\", b=0 } = {}): void {\n    // ...\n}\nf();\n```\n> 上面的代码是一个类型推断的例子，将在本手册后文介绍。\n\n其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：\n``` typescript\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n    // ...\n}\nf({ a: \"yes\" }); // ok, default b = 0\nf(); // ok, default to {a: \"\"}, which then defaults b = 0\nf({}); // error, 'a' is required if you supply an argument\n```\n要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。\n展开\n\n展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：\n``` typescript\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。\n\n你还可以展开对象：\n``` typescript\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { ...defaults, food: \"rich\" };\n```\nsearch的值为{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：\n``` typescript\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { food: \"rich\", ...defaults };\n```\n那么，defaults里的food属性会重写food: \"rich\"，在这里这并不是我们想要的结果。\n\n对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：\n``` typescript\nclass C {\n  p = 12;\n  m() {\n  }\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n```\n其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。 ","slug":"typescript-2","published":1,"date":"2020-09-16T09:04:24.965Z","updated":"2020-09-16T09:30:23.367Z","layout":"post","photos":[],"link":"","_id":"ckfcgz640000cijob7g9hgv0v","content":"<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><p>let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。</p>\n<p>因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。</p>\n<p>如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 var声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>\n<h3 id=\"var-声明\"><a href=\"#var-声明\" class=\"headerlink\" title=\"var 声明\"></a>var 声明</h3><p>一直以来我们都是通过var关键字定义JavaScript变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>大家都能理解，这里定义了一个名为a值为10的变量。</p>\n<p>我们也可以在函数内部定义变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且我们也可以在其它函数内部访问相同的变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\">g(); <span class=\"comment\">// returns 11;</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = g();</span><br><span class=\"line\">    a = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// returns 2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"作用域规则\"><a href=\"#作用域规则\" class=\"headerlink\" title=\"作用域规则\"></a>作用域规则</h3><p>对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">shouldInitialize: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">true</span>);  <span class=\"comment\">// returns &#x27;10&#x27;</span></span><br><span class=\"line\">f(<span class=\"literal\">false</span>); <span class=\"comment\">// returns &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>有些读者可能要多看几遍这个例子。 变量 x是定义在<em>if语句里面</em>，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为* var作用域或函数作用域*。 函数参数也使用函数作用域。</p>\n<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">            sum += currentRow[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。<br>捕获变量怪异之处</p>\n<p>快速的猜一下下面的代码会返回什么：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(i); &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。</p>\n<p>好吧，看一下结果：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<p>还记得我们上面提到的捕获变量吗？</p>\n<blockquote>\n<p>我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。</p>\n</blockquote>\n<p>让我们花点时间思考一下这是为什么。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出 10！</p>\n<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// capture the current state of &#x27;i&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// by invoking a function with its current value</span></span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(i); &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种奇怪的形式我们已经司空见惯了。 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。</p>\n<h3 id=\"let-声明\"><a href=\"#let-声明\" class=\"headerlink\" title=\"let 声明\"></a>let 声明</h3><p>现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外， let与var的写法一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>\n<h3 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h3><p>当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">input: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Still okay to reference &#x27;a&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Error: &#x27;b&#x27; doesn&#x27;t exist here</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。</p>\n<p>在catch语句里声明的变量也具有同样的作用域规则。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">&quot;oh no!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Oh well.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: &#x27;e&#x27; doesn&#x27;t exist here</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e);</span><br></pre></td></tr></table></figure>\n<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++; <span class=\"comment\">// illegal to use &#x27;a&#x27; before it&#x27;s declared;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// okay to capture &#x27;a&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能在&#x27;a&#x27;被声明前调用&#x27;foo&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 运行时应该抛出错误</span></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n<p>关于暂时性死区的更多信息，查看这里Mozilla Developer Network.</p>\n<h3 id=\"重定义及屏蔽\"><a href=\"#重定义及屏蔽\" class=\"headerlink\" title=\"重定义及屏蔽\"></a>重定义及屏蔽</h3><p>我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， let声明就不会这么宽松了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span>; <span class=\"comment\">// 错误，不能在1个作用域里多次声明`x`</span></span><br></pre></td></tr></table></figure>\n<p>并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// error: interferes with parameter declaration</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// error: can&#x27;t have both declarations of &#x27;x&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">condition, x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">false</span>, <span class=\"number\">0</span>); <span class=\"comment\">// returns 0</span></span><br><span class=\"line\">f(<span class=\"literal\">true</span>, <span class=\"number\">0</span>);  <span class=\"comment\">// returns 100</span></span><br></pre></td></tr></table></figure>\n<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">            sum += currentRow[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。</p>\n<p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。<br>块级作用域变量的获取</p>\n<p>在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">theCityThatAlwaysSleeps</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> getCity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> city = <span class=\"string\">&quot;Seattle&quot;</span>;</span><br><span class=\"line\">        getCity = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getCity();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。</p>\n<p>回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</p>\n<p>当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(i); &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会输出与预料一致的结果：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"const-声明\"><a href=\"#const-声明\" class=\"headerlink\" title=\"const 声明\"></a>const 声明</h3><p>const 声明是声明变量的另一种方式。</p>\n<p>const numLivesForCat = 9;</p>\n<p>它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。</p>\n<p>这很好理解，它们引用的值是不可变的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;Aurora&quot;</span>,</span><br><span class=\"line\">    numLives: numLivesForCat,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;Danielle&quot;</span>,</span><br><span class=\"line\">    numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// all &quot;okay&quot;</span></span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Rory&quot;</span>;</span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Kitty&quot;</span>;</span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Cat&quot;</span>;</span><br><span class=\"line\">kitty.numLives--;</span><br></pre></td></tr></table></figure>\n<p>除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。</p>\n<h3 id=\"let-vs-const\"><a href=\"#let-vs-const\" class=\"headerlink\" title=\"let vs. const\"></a>let vs. const</h3><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p>\n<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。</p>\n<p>跟据你的自己判断，如果合适的话，与团队成员商议一下。</p>\n<p>这个手册大部分地方都使用了let声明。<br>解构</p>\n<p>Another TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 the article on the Mozilla Developer Network。 本章，我们将给出一个简短的概述。<br>解构数组</p>\n<p>最简单的解构莫过于数组的解构赋值了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second); <span class=\"comment\">// outputs 2</span></span><br></pre></td></tr></table></figure>\n<p>这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first = input[<span class=\"number\">0</span>];</span><br><span class=\"line\">second = input[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<p>解构作用于已声明的变量会更好：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// swap variables</span></span><br><span class=\"line\">[first, second] = [second, first];</span><br></pre></td></tr></table></figure>\n<p>作用于函数参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(first);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(second);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(input);</span><br></pre></td></tr></table></figure>\n<p>你可以在数组里使用…语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n<p>或其它元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n<p>对象解构</p>\n<p>你也可以解构对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    b: <span class=\"number\">12</span>,</span><br><span class=\"line\">    c: <span class=\"string\">&quot;bar&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure>\n<p>这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。</p>\n<p>就像数组解构，你可以用没有声明的赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123; a, b &#125; = &#123; a: <span class=\"string\">&quot;baz&quot;</span>, b: <span class=\"number\">101</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。</p>\n<p>你可以在对象里使用…语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.b + passthrough.c.length;</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性重命名\"><a href=\"#属性重命名\" class=\"headerlink\" title=\"属性重命名\"></a>属性重命名</h3><p>你也可以给属性以不同的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a: newName1, b: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>\n<p>这里的语法开始变得混乱。 你可以将 a: newName1 读做 “a 作为 newName1”。 方向是从左到右，好像你写成了以下样子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.a;</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.b;</span><br></pre></td></tr></table></figure>\n<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125;: &#123;a: <span class=\"built_in\">string</span>, b: <span class=\"built_in\">number</span>&#125; = o;</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p>默认值可以让你在属性为 undefined 时使用缺省值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。<br>函数声明</p>\n<p>解构也能用于函数声明。 看以下简单的情况：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a=&quot;&quot;, b=0 &#125; = &#123;&#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的代码是一个类型推断的例子，将在本手册后文介绍。</p>\n</blockquote>\n<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b = 0 &#125; = &#123; a: &quot;&quot; &#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; a: <span class=\"string\">&quot;yes&quot;</span> &#125;); <span class=\"comment\">// ok, default b = 0</span></span><br><span class=\"line\">f(); <span class=\"comment\">// ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0</span></span><br><span class=\"line\">f(&#123;&#125;); <span class=\"comment\">// error, &#x27;a&#x27; is required if you supply an argument</span></span><br></pre></td></tr></table></figure>\n<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。<br>展开</p>\n<p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n<p>这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。</p>\n<p>你还可以展开对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">&quot;spicy&quot;</span>, price: <span class=\"string\">&quot;$$&quot;</span>, ambiance: <span class=\"string\">&quot;noisy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, food: <span class=\"string\">&quot;rich&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p>search的值为{ food: “rich”, price: “$$”, ambiance: “noisy” }。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">&quot;spicy&quot;</span>, price: <span class=\"string\">&quot;$$&quot;</span>, ambiance: <span class=\"string\">&quot;noisy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; food: <span class=\"string\">&quot;rich&quot;</span>, ...defaults &#125;;</span><br></pre></td></tr></table></figure>\n<p>那么，defaults里的food属性会重写food: “rich”，在这里这并不是我们想要的结果。</p>\n<p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> C &#123;</span><br><span class=\"line\">  p = <span class=\"number\">12</span>;</span><br><span class=\"line\">  m() &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = &#123; ...c &#125;;</span><br><span class=\"line\">clone.p; <span class=\"comment\">// ok</span></span><br><span class=\"line\">clone.m(); <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。 </p>\n","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":"<h3 id=\"变量声明\"><a href=\"#变量声明\" class=\"headerlink\" title=\"变量声明\"></a>变量声明</h3><p>let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。</p>\n<p>因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。</p>\n<p>如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 var声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>\n<h3 id=\"var-声明\"><a href=\"#var-声明\" class=\"headerlink\" title=\"var 声明\"></a>var 声明</h3><p>一直以来我们都是通过var关键字定义JavaScript变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>大家都能理解，这里定义了一个名为a值为10的变量。</p>\n<p>我们也可以在函数内部定义变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> message = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且我们也可以在其它函数内部访问相同的变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\">g(); <span class=\"comment\">// returns 11;</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    a = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = g();</span><br><span class=\"line\">    a = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// returns 2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"作用域规则\"><a href=\"#作用域规则\" class=\"headerlink\" title=\"作用域规则\"></a>作用域规则</h3><p>对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">shouldInitialize: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">true</span>);  <span class=\"comment\">// returns &#x27;10&#x27;</span></span><br><span class=\"line\">f(<span class=\"literal\">false</span>); <span class=\"comment\">// returns &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>有些读者可能要多看几遍这个例子。 变量 x是定义在<em>if语句里面</em>，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为* var作用域或函数作用域*。 函数参数也使用函数作用域。</p>\n<p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">            sum += currentRow[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。<br>捕获变量怪异之处</p>\n<p>快速的猜一下下面的代码会返回什么：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(i); &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。</p>\n<p>好吧，看一下结果：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<p>很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<p>还记得我们上面提到的捕获变量吗？</p>\n<blockquote>\n<p>我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。</p>\n</blockquote>\n<p>让我们花点时间思考一下这是为什么。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出 10！</p>\n<p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// capture the current state of &#x27;i&#x27;</span></span><br><span class=\"line\">    <span class=\"comment\">// by invoking a function with its current value</span></span><br><span class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"built_in\">console</span>.log(i); &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种奇怪的形式我们已经司空见惯了。 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。</p>\n<h3 id=\"let-声明\"><a href=\"#let-声明\" class=\"headerlink\" title=\"let 声明\"></a>let 声明</h3><p>现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外， let与var的写法一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>\n<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>\n<h3 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h3><p>当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">input: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Still okay to reference &#x27;a&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Error: &#x27;b&#x27; doesn&#x27;t exist here</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。</p>\n<p>在catch语句里声明的变量也具有同样的作用域规则。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">&quot;oh no!&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Oh well.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: &#x27;e&#x27; doesn&#x27;t exist here</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e);</span><br></pre></td></tr></table></figure>\n<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++; <span class=\"comment\">// illegal to use &#x27;a&#x27; before it&#x27;s declared;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// okay to capture &#x27;a&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能在&#x27;a&#x27;被声明前调用&#x27;foo&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 运行时应该抛出错误</span></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n<p>关于暂时性死区的更多信息，查看这里Mozilla Developer Network.</p>\n<h3 id=\"重定义及屏蔽\"><a href=\"#重定义及屏蔽\" class=\"headerlink\" title=\"重定义及屏蔽\"></a>重定义及屏蔽</h3><p>我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， let声明就不会这么宽松了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span>; <span class=\"comment\">// 错误，不能在1个作用域里多次声明`x`</span></span><br></pre></td></tr></table></figure>\n<p>并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// error: interferes with parameter declaration</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// error: can&#x27;t have both declarations of &#x27;x&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">condition, x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">false</span>, <span class=\"number\">0</span>); <span class=\"comment\">// returns 0</span></span><br><span class=\"line\">f(<span class=\"literal\">true</span>, <span class=\"number\">0</span>);  <span class=\"comment\">// returns 100</span></span><br></pre></td></tr></table></figure>\n<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">            sum += currentRow[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。</p>\n<p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。<br>块级作用域变量的获取</p>\n<p>在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">theCityThatAlwaysSleeps</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> getCity;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> city = <span class=\"string\">&quot;Seattle&quot;</span>;</span><br><span class=\"line\">        getCity = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getCity();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。</p>\n<p>回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</p>\n<p>当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> ; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"built_in\">console</span>.log(i); &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>会输出与预料一致的结果：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"const-声明\"><a href=\"#const-声明\" class=\"headerlink\" title=\"const 声明\"></a>const 声明</h3><p>const 声明是声明变量的另一种方式。</p>\n<p>const numLivesForCat = 9;</p>\n<p>它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。</p>\n<p>这很好理解，它们引用的值是不可变的。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;Aurora&quot;</span>,</span><br><span class=\"line\">    numLives: numLivesForCat,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">&quot;Danielle&quot;</span>,</span><br><span class=\"line\">    numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// all &quot;okay&quot;</span></span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Rory&quot;</span>;</span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Kitty&quot;</span>;</span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Cat&quot;</span>;</span><br><span class=\"line\">kitty.numLives--;</span><br></pre></td></tr></table></figure>\n<p>除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。</p>\n<h3 id=\"let-vs-const\"><a href=\"#let-vs-const\" class=\"headerlink\" title=\"let vs. const\"></a>let vs. const</h3><p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p>\n<p>使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。</p>\n<p>跟据你的自己判断，如果合适的话，与团队成员商议一下。</p>\n<p>这个手册大部分地方都使用了let声明。<br>解构</p>\n<p>Another TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 the article on the Mozilla Developer Network。 本章，我们将给出一个简短的概述。<br>解构数组</p>\n<p>最简单的解构莫过于数组的解构赋值了：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second); <span class=\"comment\">// outputs 2</span></span><br></pre></td></tr></table></figure>\n<p>这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first = input[<span class=\"number\">0</span>];</span><br><span class=\"line\">second = input[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n<p>解构作用于已声明的变量会更好：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// swap variables</span></span><br><span class=\"line\">[first, second] = [second, first];</span><br></pre></td></tr></table></figure>\n<p>作用于函数参数：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(first);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(second);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(input);</span><br></pre></td></tr></table></figure>\n<p>你可以在数组里使用…语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n<p>当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n<p>或其它元素：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n<p>对象解构</p>\n<p>你也可以解构对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">    a: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">    b: <span class=\"number\">12</span>,</span><br><span class=\"line\">    c: <span class=\"string\">&quot;bar&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure>\n<p>这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。</p>\n<p>就像数组解构，你可以用没有声明的赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123; a, b &#125; = &#123; a: <span class=\"string\">&quot;baz&quot;</span>, b: <span class=\"number\">101</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。</p>\n<p>你可以在对象里使用…语法创建剩余变量：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.b + passthrough.c.length;</span><br></pre></td></tr></table></figure>\n<h3 id=\"属性重命名\"><a href=\"#属性重命名\" class=\"headerlink\" title=\"属性重命名\"></a>属性重命名</h3><p>你也可以给属性以不同的名字：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a: newName1, b: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>\n<p>这里的语法开始变得混乱。 你可以将 a: newName1 读做 “a 作为 newName1”。 方向是从左到右，好像你写成了以下样子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.a;</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.b;</span><br></pre></td></tr></table></figure>\n<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123;a, b&#125;: &#123;a: <span class=\"built_in\">string</span>, b: <span class=\"built_in\">number</span>&#125; = o;</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p>默认值可以让你在属性为 undefined 时使用缺省值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。<br>函数声明</p>\n<p>解构也能用于函数声明。 看以下简单的情况：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; a: <span class=\"built_in\">string</span>, b?: <span class=\"built_in\">number</span> &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a=&quot;&quot;, b=0 &#125; = &#123;&#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>上面的代码是一个类型推断的例子，将在本手册后文介绍。</p>\n</blockquote>\n<p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b = 0 &#125; = &#123; a: &quot;&quot; &#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; a: <span class=\"string\">&quot;yes&quot;</span> &#125;); <span class=\"comment\">// ok, default b = 0</span></span><br><span class=\"line\">f(); <span class=\"comment\">// ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0</span></span><br><span class=\"line\">f(&#123;&#125;); <span class=\"comment\">// error, &#x27;a&#x27; is required if you supply an argument</span></span><br></pre></td></tr></table></figure>\n<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。<br>展开</p>\n<p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n<p>这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。</p>\n<p>你还可以展开对象：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">&quot;spicy&quot;</span>, price: <span class=\"string\">&quot;$$&quot;</span>, ambiance: <span class=\"string\">&quot;noisy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, food: <span class=\"string\">&quot;rich&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>\n<p>search的值为{ food: “rich”, price: “$$”, ambiance: “noisy” }。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; food: <span class=\"string\">&quot;spicy&quot;</span>, price: <span class=\"string\">&quot;$$&quot;</span>, ambiance: <span class=\"string\">&quot;noisy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; food: <span class=\"string\">&quot;rich&quot;</span>, ...defaults &#125;;</span><br></pre></td></tr></table></figure>\n<p>那么，defaults里的food属性会重写food: “rich”，在这里这并不是我们想要的结果。</p>\n<p>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> C &#123;</span><br><span class=\"line\">  p = <span class=\"number\">12</span>;</span><br><span class=\"line\">  m() &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = &#123; ...c &#125;;</span><br><span class=\"line\">clone.p; <span class=\"comment\">// ok</span></span><br><span class=\"line\">clone.m(); <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。 </p>\n"},{"title":"接口","comments":1,"_content":"\n### 介绍\n\nTypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n### 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n```typescript\nfunction printLabel(labelledObj: { label: string }) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = { size: 10, label: \"Size 10 Object\" };\nprintLabel(myObj);\n```\n类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：\n``` typescript\ninterface LabelledValue {\n  label: string;\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\nLabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n### 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。\n\n下面是应用了“option bags”的例子：\n``` typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): {color: string; area: number} {\n  let newSquare = {color: \"white\", area: 100};\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n```\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：\n``` typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = {color: \"white\", area: 100};\n  if (config.clor) {\n    // Error: Property 'clor' does not exist on type 'SquareConfig'\n    newSquare.color = config.clor;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n```\n### 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:\n``` typescript\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。\n``` typescript\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n```\nTypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n``` typescript\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n```\n上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n``` typescript\na = ro as number[];\n\nreadonly vs const\n```\n最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。\n额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。\n\n然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：\n``` typescript\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    // ...\n}\n\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\n```\n注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。\n\n然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n``` typescript\n// error: 'colour' not expected in type 'SquareConfig'\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\n```\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n``` typescript\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n```\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：\n``` typescript\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n```\n我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。\n``` typescript\nlet squareOptions = { colour: \"red\", width: 100 };\nlet mySquare = createSquare(squareOptions);\n```\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。\n函数类型\n\n接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n``` typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n```\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n``` typescript\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n}\n```\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n``` typescript\nlet mySearch: SearchFunc;\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1;\n}\n```\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。\n``` typescript\nlet mySearch: SearchFunc;\nmySearch = function(src, sub) {\n    let result = src.search(sub);\n    return result > -1;\n}\n```\n### 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[\"daniel\"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n``` typescript\ninterface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\n\nlet myStr: string = myArray[0];\n```\n上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。\n\nTypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用\"100\"（一个string）去索引，因此两者需要保持一致。\n``` typescript\nclass Animal {\n    name: string;\n}\nclass Dog extends Animal {\n    breed: string;\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n    [x: number]: Animal;\n    [x: string]: Dog;\n}\n```\n字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[\"property\"]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n``` typescript\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n``` typescript\ninterface ReadonlyStringArray {\n    readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];\nmyArray[2] = \"Mallory\"; // error!\n```\n你不能设置myArray[2]，因为索引签名是只读的。\n类类型\n### 实现接口\n\n与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。\n``` typescript\ninterface ClockInterface {\n    currentTime: Date;\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date;\n    constructor(h: number, m: number) { }\n}\n```\n你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：\n``` typescript\ninterface ClockInterface {\n    currentTime: Date;\n    setTime(d: Date);\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date;\n    setTime(d: Date) {\n        this.currentTime = d;\n    }\n    constructor(h: number, m: number) { }\n}\n```\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n### 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n``` typescript\ninterface ClockConstructor {\n    new (hour: number, minute: number);\n}\n\nclass Clock implements ClockConstructor {\n    currentTime: Date;\n    constructor(h: number, m: number) { }\n}\n```\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。\n\n因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。\n``` typescript\ninterface ClockConstructor {\n    new (hour: number, minute: number): ClockInterface;\n}\ninterface ClockInterface {\n    tick();\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n    return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log(\"beep beep\");\n    }\n}\nclass AnalogClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log(\"tick tock\");\n    }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n```\n因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。\n继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n``` typescript\ninterface Shape {\n    color: string;\n}\n\ninterface Square extends Shape {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\n```\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n``` typescript\ninterface Shape {\n    color: string;\n}\n\ninterface PenStroke {\n    penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n### 混合类型\n\n先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n``` typescript\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = <Counter>function (start: number) { };\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```\n在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。\n### 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：\n``` typescript\nclass Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n    select() { }\n}\n\nclass TextBox extends Control {\n    select() { }\n}\n\n// 错误：“Image”类型缺少“state”属性。\nclass Image implements SelectableControl {\n    select() { }\n}\n\nclass Location {\n\n}\n```\n在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。\n\n在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。","source":"_posts/typescript-3.md","raw":"---\ntitle: 接口\ncategories: 编程语言\ntags: TypeScript\ncomments: true\n---\n\n### 介绍\n\nTypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\n### 接口初探\n\n下面通过一个简单示例来观察接口是如何工作的：\n```typescript\nfunction printLabel(labelledObj: { label: string }) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = { size: 10, label: \"Size 10 Object\" };\nprintLabel(myObj);\n```\n类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。\n\n下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：\n``` typescript\ninterface LabelledValue {\n  label: string;\n}\n\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\n\nlet myObj = {size: 10, label: \"Size 10 Object\"};\nprintLabel(myObj);\n```\nLabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。\n\n还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。\n### 可选属性\n\n接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。\n\n下面是应用了“option bags”的例子：\n``` typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): {color: string; area: number} {\n  let newSquare = {color: \"white\", area: 100};\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n```\n带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。\n\n可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：\n``` typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = {color: \"white\", area: 100};\n  if (config.clor) {\n    // Error: Property 'clor' does not exist on type 'SquareConfig'\n    newSquare.color = config.clor;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n\nlet mySquare = createSquare({color: \"black\"});\n```\n### 只读属性\n\n一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:\n``` typescript\ninterface Point {\n    readonly x: number;\n    readonly y: number;\n}\n```\n你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。\n``` typescript\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\n```\nTypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：\n``` typescript\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\nro[0] = 12; // error!\nro.push(5); // error!\nro.length = 100; // error!\na = ro; // error!\n```\n上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：\n``` typescript\na = ro as number[];\n\nreadonly vs const\n```\n最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。\n额外的属性检查\n\n我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。\n\n然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：\n``` typescript\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n}\n\nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n    // ...\n}\n\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\n```\n注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。\n\n你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。\n\n然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。\n``` typescript\n// error: 'colour' not expected in type 'SquareConfig'\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\n```\n绕开这些检查非常简单。 最简便的方法是使用类型断言：\n``` typescript\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\n```\n然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：\n``` typescript\ninterface SquareConfig {\n    color?: string;\n    width?: number;\n    [propName: string]: any;\n}\n```\n我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。\n\n还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。\n``` typescript\nlet squareOptions = { colour: \"red\", width: 100 };\nlet mySquare = createSquare(squareOptions);\n```\n要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。\n函数类型\n\n接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。\n\n为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n``` typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n```\n这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n``` typescript\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n}\n```\n对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：\n``` typescript\nlet mySearch: SearchFunc;\nmySearch = function(src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1;\n}\n```\n函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。\n``` typescript\nlet mySearch: SearchFunc;\nmySearch = function(src, sub) {\n    let result = src.search(sub);\n    return result > -1;\n}\n```\n### 可索引的类型\n\n与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[\"daniel\"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n``` typescript\ninterface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\n\nlet myStr: string = myArray[0];\n```\n上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。\n\nTypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用\"100\"（一个string）去索引，因此两者需要保持一致。\n``` typescript\nclass Animal {\n    name: string;\n}\nclass Dog extends Animal {\n    breed: string;\n}\n\n// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!\ninterface NotOkay {\n    [x: number]: Animal;\n    [x: string]: Dog;\n}\n```\n字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[\"property\"]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：\n``` typescript\ninterface NumberDictionary {\n  [index: string]: number;\n  length: number;    // 可以，length是number类型\n  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配\n}\n```\n最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：\n``` typescript\ninterface ReadonlyStringArray {\n    readonly [index: number]: string;\n}\nlet myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];\nmyArray[2] = \"Mallory\"; // error!\n```\n你不能设置myArray[2]，因为索引签名是只读的。\n类类型\n### 实现接口\n\n与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。\n``` typescript\ninterface ClockInterface {\n    currentTime: Date;\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date;\n    constructor(h: number, m: number) { }\n}\n```\n你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：\n``` typescript\ninterface ClockInterface {\n    currentTime: Date;\n    setTime(d: Date);\n}\n\nclass Clock implements ClockInterface {\n    currentTime: Date;\n    setTime(d: Date) {\n        this.currentTime = d;\n    }\n    constructor(h: number, m: number) { }\n}\n```\n接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。\n### 类静态部分与实例部分的区别\n\n当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：\n``` typescript\ninterface ClockConstructor {\n    new (hour: number, minute: number);\n}\n\nclass Clock implements ClockConstructor {\n    currentTime: Date;\n    constructor(h: number, m: number) { }\n}\n```\n这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。\n\n因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。\n``` typescript\ninterface ClockConstructor {\n    new (hour: number, minute: number): ClockInterface;\n}\ninterface ClockInterface {\n    tick();\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n    return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log(\"beep beep\");\n    }\n}\nclass AnalogClock implements ClockInterface {\n    constructor(h: number, m: number) { }\n    tick() {\n        console.log(\"tick tock\");\n    }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\n```\n因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。\n继承接口\n\n和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。\n``` typescript\ninterface Shape {\n    color: string;\n}\n\ninterface Square extends Shape {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\n```\n一个接口可以继承多个接口，创建出多个接口的合成接口。\n``` typescript\ninterface Shape {\n    color: string;\n}\n\ninterface PenStroke {\n    penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n    sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n### 混合类型\n\n先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。\n``` typescript\ninterface Counter {\n    (start: number): string;\n    interval: number;\n    reset(): void;\n}\n\nfunction getCounter(): Counter {\n    let counter = <Counter>function (start: number) { };\n    counter.interval = 123;\n    counter.reset = function () { };\n    return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```\n在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。\n### 接口继承类\n\n当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。\n\n当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：\n``` typescript\nclass Control {\n    private state: any;\n}\n\ninterface SelectableControl extends Control {\n    select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n    select() { }\n}\n\nclass TextBox extends Control {\n    select() { }\n}\n\n// 错误：“Image”类型缺少“state”属性。\nclass Image implements SelectableControl {\n    select() { }\n}\n\nclass Location {\n\n}\n```\n在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。\n\n在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。","slug":"typescript-3","published":1,"date":"2020-09-16T09:17:34.597Z","updated":"2020-09-16T09:46:57.291Z","layout":"post","photos":[],"link":"","_id":"ckfcgz641000dijobflf51qek","content":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>\n<h3 id=\"接口初探\"><a href=\"#接口初探\" class=\"headerlink\" title=\"接口初探\"></a>接口初探</h3><p>下面通过一个简单示例来观察接口是如何工作的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: &#123; label: <span class=\"built_in\">string</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123; size: <span class=\"number\">10</span>, label: <span class=\"string\">&quot;Size 10 Object&quot;</span> &#125;;</span><br><span class=\"line\">printLabel(myObj);</span><br></pre></td></tr></table></figure>\n<p>类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>\n<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelledValue &#123;</span><br><span class=\"line\">  label: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;size: <span class=\"number\">10</span>, label: <span class=\"string\">&quot;Size 10 Object&quot;</span>&#125;;</span><br><span class=\"line\">printLabel(myObj);</span><br></pre></td></tr></table></figure>\n<p>LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>\n<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<h3 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h3><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>\n<p>下面是应用了“option bags”的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123;color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span>&#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">&quot;white&quot;</span>, area: <span class=\"number\">100</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">&quot;black&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\n<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p>\n<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">&quot;white&quot;</span>, area: <span class=\"number\">100</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.clor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Error: Property &#x27;clor&#x27; does not exist on type &#x27;SquareConfig&#x27;</span></span><br><span class=\"line\">    newSquare.color = config.clor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">&quot;black&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Point &#123;</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1: Point = &#123; x: <span class=\"number\">10</span>, y: <span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">p1.x = <span class=\"number\">5</span>; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> ro: ReadonlyArray&lt;<span class=\"built_in\">number</span>&gt; = a;</span><br><span class=\"line\">ro[<span class=\"number\">0</span>] = <span class=\"number\">12</span>; <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.push(<span class=\"number\">5</span>); <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.length = <span class=\"number\">100</span>; <span class=\"comment\">// error!</span></span><br><span class=\"line\">a = ro; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = ro <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">readonly</span> vs <span class=\"keyword\">const</span></span><br></pre></td></tr></table></figure>\n<p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。<br>额外的属性检查</p>\n<p>我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>\n<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">&quot;red&quot;</span>, width: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。</p>\n<p>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。</p>\n<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">&quot;red&quot;</span>, width: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; width: <span class=\"number\">100</span>, opacity: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>\n<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</p>\n<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> squareOptions = &#123; colour: <span class=\"string\">&quot;red&quot;</span>, width: <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>\n<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。<br>函数类型</p>\n<p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>\n<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc &#123;</span><br><span class=\"line\">  (source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = source.search(subString);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src: <span class=\"built_in\">string</span>, sub: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src, sub</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = src.search(sub);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可索引的类型\"><a href=\"#可索引的类型\" class=\"headerlink\" title=\"可索引的类型\"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: StringArray;</span><br><span class=\"line\">myArray = [<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Fred&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myStr: <span class=\"built_in\">string</span> = myArray[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。</p>\n<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">    breed: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotOkay &#123;</span><br><span class=\"line\">    [x: <span class=\"built_in\">number</span>]: Animal;</span><br><span class=\"line\">    [x: <span class=\"built_in\">string</span>]: Dog;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NumberDictionary &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span>;    <span class=\"comment\">// 可以，length是number类型</span></span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>       <span class=\"comment\">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ReadonlyStringArray &#123;</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: ReadonlyStringArray = [<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>];</span><br><span class=\"line\">myArray[<span class=\"number\">2</span>] = <span class=\"string\">&quot;Mallory&quot;</span>; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>你不能设置myArray[2]，因为索引签名是只读的。<br>类类型</p>\n<h3 id=\"实现接口\"><a href=\"#实现接口\" class=\"headerlink\" title=\"实现接口\"></a>实现接口</h3><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.currentTime = d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>\n<h3 id=\"类静态部分与实例部分的区别\"><a href=\"#类静态部分与实例部分的区别\" class=\"headerlink\" title=\"类静态部分与实例部分的区别\"></a>类静态部分与实例部分的区别</h3><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockConstructor &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p>\n<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>): ClockInterface;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">    tick();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createClock</span>(<span class=\"params\">ctor: ClockConstructor, hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span></span>): <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ctor(hour, minute);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> DigitalClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">    tick() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;beep beep&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> AnalogClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">    tick() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;tick tock&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = createClock(DigitalClock, <span class=\"number\">12</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = createClock(AnalogClock, <span class=\"number\">7</span>, <span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n<p>因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。<br>继承接口</p>\n<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">    color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape &#123;</span><br><span class=\"line\">    sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">    color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke &#123;</span><br><span class=\"line\">    penWidth: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape, PenStroke &#123;</span><br><span class=\"line\">    sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span>;</span><br><span class=\"line\">square.penWidth = <span class=\"number\">5.0</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h3><p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>\n<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">    (start: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    interval: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    reset(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> counter = &lt;Counter&gt;<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123; &#125;;</span><br><span class=\"line\">    counter.interval = <span class=\"number\">123</span>;</span><br><span class=\"line\">    counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter();</span><br><span class=\"line\">c(<span class=\"number\">10</span>);</span><br><span class=\"line\">c.reset();</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span>;</span><br></pre></td></tr></table></figure>\n<p>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>\n<h3 id=\"接口继承类\"><a href=\"#接口继承类\" class=\"headerlink\" title=\"接口继承类\"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>\n<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Control &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">    select(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Button <span class=\"keyword\">extends</span> Control <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> TextBox <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Image <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Location &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。</p>\n<p>在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</p>\n","site":{"data":{"friends":[{"avatar":"https://www.lixl.cn/medias/avatar.jpg","name":"悟尘记","introduction":"人生就是一场修行，上善若水，厚德载物。","url":"https://www.lixl.cn/","title":"前去参观"},{"avatar":"https://wiki.hyperledger.org/download/attachments/2392069/fabric?version=1&modificationDate=1540928132000&api=v2","name":"Fabric","introduction":"A Blockchain Platform for the Enterprise","url":"https://hyperledger-fabric.readthedocs.io/en/master/","title":"前去学习"},{"avatar":"https://www.bootcdn.cn/assets/img/maoyun.svg","name":"BootCDN","introduction":"稳定、快速、免费的前端开源项目 CDN 加速服务。","url":"https://www.bootcdn.cn/","title":"前去加速"}]}},"excerpt":"","more":"<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>\n<h3 id=\"接口初探\"><a href=\"#接口初探\" class=\"headerlink\" title=\"接口初探\"></a>接口初探</h3><p>下面通过一个简单示例来观察接口是如何工作的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: &#123; label: <span class=\"built_in\">string</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123; size: <span class=\"number\">10</span>, label: <span class=\"string\">&quot;Size 10 Object&quot;</span> &#125;;</span><br><span class=\"line\">printLabel(myObj);</span><br></pre></td></tr></table></figure>\n<p>类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。</p>\n<p>下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelledValue &#123;</span><br><span class=\"line\">  label: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;size: <span class=\"number\">10</span>, label: <span class=\"string\">&quot;Size 10 Object&quot;</span>&#125;;</span><br><span class=\"line\">printLabel(myObj);</span><br></pre></td></tr></table></figure>\n<p>LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。</p>\n<p>还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<h3 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h3><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>\n<p>下面是应用了“option bags”的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123;color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span>&#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">&quot;white&quot;</span>, area: <span class=\"number\">100</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">&quot;black&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\n<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。</p>\n<p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123;color: <span class=\"string\">&quot;white&quot;</span>, area: <span class=\"number\">100</span>&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.clor) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Error: Property &#x27;clor&#x27; does not exist on type &#x27;SquareConfig&#x27;</span></span><br><span class=\"line\">    newSquare.color = config.clor;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123;color: <span class=\"string\">&quot;black&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"只读属性\"><a href=\"#只读属性\" class=\"headerlink\" title=\"只读属性\"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Point &#123;</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1: Point = &#123; x: <span class=\"number\">10</span>, y: <span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">p1.x = <span class=\"number\">5</span>; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> ro: ReadonlyArray&lt;<span class=\"built_in\">number</span>&gt; = a;</span><br><span class=\"line\">ro[<span class=\"number\">0</span>] = <span class=\"number\">12</span>; <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.push(<span class=\"number\">5</span>); <span class=\"comment\">// error!</span></span><br><span class=\"line\">ro.length = <span class=\"number\">100</span>; <span class=\"comment\">// error!</span></span><br><span class=\"line\">a = ro; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = ro <span class=\"keyword\">as</span> <span class=\"built_in\">number</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">readonly</span> vs <span class=\"keyword\">const</span></span><br></pre></td></tr></table></figure>\n<p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。<br>额外的属性检查</p>\n<p>我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。</p>\n<p>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createSquare</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">&quot;red&quot;</span>, width: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。</p>\n<p>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。</p>\n<p>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; colour: <span class=\"string\">&quot;red&quot;</span>, width: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(&#123; width: <span class=\"number\">100</span>, opacity: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>\n<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">    color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。</p>\n<p>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> squareOptions = &#123; colour: <span class=\"string\">&quot;red&quot;</span>, width: <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>\n<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。<br>函数类型</p>\n<p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p>\n<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc &#123;</span><br><span class=\"line\">  (source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = source.search(subString);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src: <span class=\"built_in\">string</span>, sub: <span class=\"built_in\">string</span></span>): <span class=\"title\">boolean</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = src.search(sub);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src, sub</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = src.search(sub);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result &gt; <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可索引的类型\"><a href=\"#可索引的类型\" class=\"headerlink\" title=\"可索引的类型\"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: StringArray;</span><br><span class=\"line\">myArray = [<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Fred&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myStr: <span class=\"built_in\">string</span> = myArray[<span class=\"number\">0</span>];</span><br></pre></td></tr></table></figure>\n<p>上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。</p>\n<p>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Animal &#123;</span><br><span class=\"line\">    name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> Dog <span class=\"keyword\">extends</span> Animal &#123;</span><br><span class=\"line\">    breed: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> NotOkay &#123;</span><br><span class=\"line\">    [x: <span class=\"built_in\">number</span>]: Animal;</span><br><span class=\"line\">    [x: <span class=\"built_in\">string</span>]: Dog;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NumberDictionary &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">string</span>]: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span>;    <span class=\"comment\">// 可以，length是number类型</span></span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>       <span class=\"comment\">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ReadonlyStringArray &#123;</span><br><span class=\"line\">    <span class=\"keyword\">readonly</span> [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: ReadonlyStringArray = [<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>];</span><br><span class=\"line\">myArray[<span class=\"number\">2</span>] = <span class=\"string\">&quot;Mallory&quot;</span>; <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n<p>你不能设置myArray[2]，因为索引签名是只读的。<br>类类型</p>\n<h3 id=\"实现接口\"><a href=\"#实现接口\" class=\"headerlink\" title=\"实现接口\"></a>实现接口</h3><p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.currentTime = d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>\n<h3 id=\"类静态部分与实例部分的区别\"><a href=\"#类静态部分与实例部分的区别\" class=\"headerlink\" title=\"类静态部分与实例部分的区别\"></a>类静态部分与实例部分的区别</h3><p>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockConstructor &#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p>\n<p>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">    <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span>): ClockInterface;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">    tick();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createClock</span>(<span class=\"params\">ctor: ClockConstructor, hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span></span>): <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ctor(hour, minute);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> DigitalClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">    tick() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;beep beep&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> AnalogClock <span class=\"keyword\">implements</span> ClockInterface &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123; &#125;</span><br><span class=\"line\">    tick() &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;tick tock&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = createClock(DigitalClock, <span class=\"number\">12</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = createClock(AnalogClock, <span class=\"number\">7</span>, <span class=\"number\">32</span>);</span><br></pre></td></tr></table></figure>\n<p>因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。<br>继承接口</p>\n<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">    color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape &#123;</span><br><span class=\"line\">    sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">    color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke &#123;</span><br><span class=\"line\">    penWidth: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape, PenStroke &#123;</span><br><span class=\"line\">    sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span>;</span><br><span class=\"line\">square.penWidth = <span class=\"number\">5.0</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"混合类型\"><a href=\"#混合类型\" class=\"headerlink\" title=\"混合类型\"></a>混合类型</h3><p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。</p>\n<p>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">    (start: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    interval: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    reset(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> counter = &lt;Counter&gt;<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123; &#125;;</span><br><span class=\"line\">    counter.interval = <span class=\"number\">123</span>;</span><br><span class=\"line\">    counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter();</span><br><span class=\"line\">c(<span class=\"number\">10</span>);</span><br><span class=\"line\">c.reset();</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span>;</span><br></pre></td></tr></table></figure>\n<p>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>\n<h3 id=\"接口继承类\"><a href=\"#接口继承类\" class=\"headerlink\" title=\"接口继承类\"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>\n<p>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Control &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">    select(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Button <span class=\"keyword\">extends</span> Control <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> TextBox <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> Image <span class=\"keyword\">implements</span> SelectableControl &#123;</span><br><span class=\"line\">    select() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Location &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。</p>\n<p>在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckfcgz6340003ijob59f4crds","category_id":"ckfcgz6380005ijobgfmfb7ta","_id":"ckfcgz63e000bijob0j9w9zer"},{"post_id":"ckfcgz640000cijob7g9hgv0v","category_id":"ckfcgz6380005ijobgfmfb7ta","_id":"ckfcgz642000gijob5yb6dpxw"},{"post_id":"ckfcgz641000dijobflf51qek","category_id":"ckfcgz6380005ijobgfmfb7ta","_id":"ckfcgz642000hijob33be2wvs"}],"PostTag":[{"post_id":"ckfcgz6340003ijob59f4crds","tag_id":"ckfcgz63a0006ijob7pamfycz","_id":"ckfcgz63e000aijob0b3t0803"},{"post_id":"ckfcgz640000cijob7g9hgv0v","tag_id":"ckfcgz63a0006ijob7pamfycz","_id":"ckfcgz642000eijobb3ja9eo7"},{"post_id":"ckfcgz641000dijobflf51qek","tag_id":"ckfcgz63a0006ijob7pamfycz","_id":"ckfcgz642000fijob89zwfosu"}],"Tag":[{"name":"TypeScript","_id":"ckfcgz63a0006ijob7pamfycz"}]}}